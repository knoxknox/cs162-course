# Notes

1. Intro
2. Processes
3. IPC & Threads
4. Synchronization
5. Memory Management
6. File System (FS/AFS/NFS)
7. Network (Sockets, TCP/IP)

# Intro

OS provide a VM abstraction to handle various hardware.<br/>
CPU operates in 2 different modes (user mode / kernel mode).<br/>
There is special 'sysmode' bit to switch from user mode to kernel mode.<br/>
Kernel mode provides an access to every resource and underlying hardware.<br/>
System calls provide an essential interface between a process and operating system.

Syscall:
```
user mode -> syscall -> kernel mode -> execute -> user mode
```

Hardware:
- I/O devices are managed by OS
- They are operate independently of main CPU
- Device uses interrupts to signal OS about event (IRQ)

Example of I/O:
1. Ethernet receives packet, writes packet into buffer
2. Network Interface Card (NIC) - signals an interrupt
3. CPU stops current instruction, saves current context
4. CPU jumps to handler address from kernel vector table
5. Ethernet device driver reads packet from buffer, processes packet
6. Kernel restores saved context and reissues interrupted instruction

Interrupt:
- software - unix signals, exceptions generated by programs (user mode)
- hardware - i/o, system timer, etc.. (signal to operating system / kernel mode)

```
---------------------------
| start executing program |
---------------------------
             |
---------------------------
|    fetch instruction    | <------------------- Yes
---------------------------                     |
             |                                  |
---------------------------                     |
|    decode instruction   |                     |
---------------------------                     |
             |                                  |
---------------------------                     |              ---------------
|   execute instruction   |                     |              | end program |
---------------------------                     |              ---------------
             |                                  |                     ^
---------------------------                     |                     |
|       interrupt ?       |                     |                     |
---------------------------                     |                     |
             |                  ---------------------------------     |
             ------------No---> | are there more instructions ? | --- No
             |                  ---------------------------------
             | Yes                              ^
             |                                  |
---------------------------                     |
|  service the interrupt  |                     |
---------------------------                     |
             |                                  |
              \                                 |
               -----------Processor----------   |
               |   Halts thread execution   |   |
               |     Saves thread state     |   |
               | Executes interrupt handler |   |
               ------------------------------   |
              /                                 |
             |                                  |
---------------------------                     |
|     resume execution    | --------------------
---------------------------
```

# Processes

Process is the OS abstraction of execution.
```
Kernel -> Load app code -> Process -> Threads
```

Process creation:
- A process is created by another process
- In Unix processes are created using fork
- Process is represented with PCB Data Structure
- Every process has 1 parent, but can have many child

PCB Data Structure:
```
pid, state, hardware state (pc, sp, regs), memory management, etc..
```

Process execution:
- OS maintains a collection of queues for processes (ready, waiting, etc..)
- Each PCB is queued to the corresponding 'queue' according to the current state
- When a process is created the OS allocates a PCB for it and places to 'ready' queue

Process representation:
- Process is instance of executing program (address space and one or more threads)

```
 0xFFFFFFFFF       -----------------
      |            |     Stack     |
      |            ----------------- <- SP
      |                    |
      |                    |
      |                    |
-------------              |
Address Space              |
-------------      -----------------
      |            |      Heap     |
      |            -----------------
      |            |  Data Segment |
      |            -----------------
      |            |  Text Segment | <- PC
 0x000000000       -----------------
```

Thread:
- single unique execution context
- program counter (indicating the next instruction), registers, execution flags, stack

Address Space:
- text segment, data segment, heap (malloc), stack (local vars, recursion)
- programs execute in address space that is distinct from the memory space of physical machine

# Threads

Each thread has its own stack & copy of cpu registers.<br/>
Shared memory between threads: heap, global vars, static objects.<br/>
Thread "yield" operation gives up the CPU to another thread (context switch).

# Synchronization

Lock, Mutex, Monitor, Semaphore, Condition variable

```
| T1 > balance = get_balance(account)
| T1 > balance = balance - amount
| T2 > balance = get_balance(account)     \
| T2 > balance = balance - amount          - context switch
| T2 > save_balance(account, balance)     /
| T1 > print_balance(account, balance)
```

Race condition - operation is not executed in proper sequence.<br/>
When this happens we need some mechanism to be ensured that all ok.<br/>
Code that uses mutual exclusion to sync its execution called critical section.<br/>
Only 1 thread at time can execute in the critical section (all other threads will wait).

# Memory Management

Processes use virtual addresses.<br/>
OS translates virtual address into physical addresses.<br/>
Processes view memory as one contiguous address space from 0 to N.

Pages:
- Page Table resides in physical memory (one per process)
- Pages are fixed-length contiguous block of virtual memory (4KB)
- Pages moved to disk when memory is full & loaded back when referenced again
- The address 0x1000 maps to different physical address in different processes

```
                                          --------
                                        0 |      |
   ----------         -----------         --------
 0 | page A |       0 | frame 3 |       1 |      |
   ----------         -----------         --------
 1 | page B |       1 |         |       2 |      |
   ----------         -----------         --------
 2 | page C |       2 | frame 5 |       3 |  &A  |
   ----------         -----------         --------
 3 | page D |       3 |         |       4 |      |
   ----------         -----------         --------
 4 | page E |       4 |         |       5 |  &C  |
   ----------         -----------         --------
 5 | page F |       5 | frame 7 |       6 |      |
   ----------         -----------         --------
 virtual-memory       page--table       7 |  &F  |
                                          --------
                                          physical
```

Segmentation:
- Technique that partitions memory into logically related units (code, data, etc..)

```
--------------------------------
| SegID      | Base   | Limit  |
--------------------------------
| 0 (code)   | 0x4000 | 0x0800 |
| 1 (data)   | 0x4800 | 0x1400 |
| 2 (shared) | 0xF000 | 0x1000 |
| 3 (stack)  | 0x0000 | 0x3000 |
--------------------------------
```
```
0x0000 ---------                0x0000 ---------- SegID=3
       |xxxxxxx| ----                  |xxxxxxxx|
       ---------    | SegID=0          |xxxxxxxx|
       |       |    |                  |xxxxxxxx|
       |       |    |                  ----------
0x4000 ---------    |                  |        |
       |xxxxxxx|--  ----------> 0x4000 ---------- SegID=0
       |xxxxxxx| |                     |xxxxxxxx|
       --------- | SegID=1             |xxxxxxxx|
       |       | -------------> 0x4800 ---------- SegID=1
       |       |                       |xxxxxxxx|
0x8000 ---------                       ----------
       |xxxxxxx|                       |        |
       ---------                       |        |
       |       |                       |        |
       |       |                       |        |
0xC000 ---------                       |        |
       |xxxxxxx|                       |        |
       |xxxxxxx|                       |        |
       |xxxxxxx|                       |        |
       ---------                       |        |
       |       |                0xF000 ---------- SegID=2
       |       |                       |xxxxxxxx|
       ---------                       ----------
        virtual                         physical
```

Swapping:
- What if not all processes fit in memory?
- In order to make room for next processes, some or all of them moved to disk

```
-------------             -------------
|           | swap out    |  ----     |
|           |-------------|->|P1|     |
|           |             |  ----     |
| UserSpace |             |           |
|           |     swap in |     ----  |
|           |<------------|-----|P2|  |
|           |             |     ----  |
-------------             -------------
 main memory              backing store
```
